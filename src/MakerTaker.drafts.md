# Maker-Taker drafts

We can use a machine learning algorithm to teach the program to write programs.

## Rosetta stone

| Machine learning                  | Programming
| -----------                       | -----------
| State                             | Current code
| Action                            | Modify the phrase (functionalize a constant, replace a variable, ...)
| Reward function                   | Test

## Main algorithm (2021-12-14)

Main idea: solve a general case by solving special cases, then combining special solutions into a general solution.

Innovations:

- An algorithm for automatic generation of special cases
- An algorithm for automatic reconciliation of special solutions

The special cases are generated by the computer. The human only needs to provide partial solutions for these special cases.

1. Transform the question into a list of axioms (logical statements that describe the problem)
   1. Axioms must include axioms about the types of the variables
   2. Axioms must not include any axioms that are not directly given by the question ([see why](#no-axiom-for-output-type)).
      1. It's possible to ask the asker to clarify the question (= specify additional axioms).
2. Transform the list of axioms into a generator that yields a lists of premises (logical statements that describe a special case of the general problem)
    1. Premises must include axioms
    2. Premises must include at least 1 additional constraint that reduces the full question to a partial question (reduces the general case to a special case).
    3. Premises must be unique across the list (generator must filter the premises that are considered equivalent under the list of axioms).
3. Transform the generator of premise lists into a generator of partial solutions (1 partial solution for 1 premise)
4. Initialize the total solution to the first value from the generator of partial solutions.
5. For each partial solution from the generator:
   1. Reconcile the current total solution with a new partial solution: each 

The "natural language" steps are only needed for communication with other humans who are not parsers.

Notes:

* A validator function is not needed: the question must be transformed to a list of logical statements (axioms) that completely describe the problem.

### No axiom for output type

Example:
1. You are given the question: "What is the root of the square equation `a*x^2 + b*x + c = 0`?"
2. You are tempted to write the axiom: `answer has type "real"` (`answer: real`). However, if `a = 0` and `b = 0` and `c != 0`, the `answer` has type `absurd` (or "empty", "bottom"), because the equation reduces to `c = 0`, which contradicts the premise `c != 0`.
3. You are tempted to write the axiom: `x has type "real"` (`x: real`). However, if `b = 0` and `sign(a) = sign(c)`, then `x` has type `complex`, because the equation reduces to `x = sqrt(-1 * c/a)`.

Therefore, it's incorrect to assume the axioms that are not given by the question (axiomatize the type of any variable, including `answer`).

## Main algorithm (2021-12-13)

1. Define an output type as a list of constructors
2. Define an input type as a list of constructors
3. Define a scoring function:
   1. Input: input-output pair
   2. Output: additional input filters
4. Define a sampling function:
   1. Input: input, general filter predicates on output, additional filter predicates
   2. Output: [?]

---

Use the map:

1. Constructor = Action
2. State = Target Function Implementation

Your Self:

1. Output is always a program for yourself (output is always code)
2. Input is always a state of yourself (input is always data)

Maker-Taker generates tasks for developers based on the code execution statistics.

---

We can refer to this fundamental property of an executor as "incompleteness" (in a tribute to [GÃ¶del's incompleteness theorems](https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems)

---

Maker-Taker outputs a pair of "current algorithm" and "current task":

* The "current algorithm" is generated from a probability distribution over possible implementations.
* The "current task" is generated from the "previous algorithm" execution statistics.

Maker-Taker minimizes the development time by tasking the developers to implement approximations instead of the ideal algorithm. The approximations are guaranteed to converge to the ideal algorithm. However, the convergence might not always be necessary in practice, because the actual execution never covers the entire domain of inputs.

---

Both Maker and Taker are functions:

* Maker outputs a list of tasks.
* Taker outputs a list of function implementations (task results).

Together, Maker and Taker are referred to as "MT system", or simply "MT".

---

Func's basic type is a term trees.

1. Define the function name.
2. Define the function input.

Func is a program that outputs a single task for a software developer based on the current state of his code. Func doesn't require any configuration.

Func is a fully automated task tracker : specialized task manager for software developers. an algorithm for writing functions. Func generates the tasks for the developer based on the current code. Each task has a form "Define output based on 1. input 2. output type".

Main ideas:

* Allow multiple input-output pairs for a single input
* Associate each input-output pair with
  * Cost of definition
    * Time
    * Money
  * Probability of execution
* Define meta-tasks (actions):
  * Define output value based on input value & output type (label: `DEVAL`)
  * Define function body based on list of input-output pairs (label: `DEFUN`)
* Define transitive meta-tasks:
  * Redefine function body = `DEVAL` of function body

BASICALLY: Each name is a probability distribution over values.

* Name can be a variable signature
* Name can be a function signature

* The developer writes an append-only list of equalities
* The system selects the correct equalities based on certain equalities marked as axioms

Replace the equality with a distribution of equalities

## Examples

### Start

```typescript
type Input = string
type Output = {} // must be defined by programmer

const add = func<Input, Output>(addMap)

const addMap: Record<Input, Output> = {}
```

`program 2 2`

## FAQ

### How can I write a program for a human?

A program for a human by writing a text in natural language which conforms to certain rules.

A human is a probabilistic executor: the same input may yield different outputs. However, it is possible to write a program for a human with a high chance of producing the expected output.

### How can I write & test a program that influences the world state probabilistically?

Every program influences the world state.

### How can I output tasks for multiple developers working on the same project?
